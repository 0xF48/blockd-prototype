// Generated by CoffeeScript 2.0.2
(function() {
  var Color, Cooldown, DECK, GRID_DIR, Game, Instance, PORT, Player, ResourceUnit, Unit, _, _time, app, bodyParser, createGame, express, fs, games, games_map, http, instances, instances_map, intersects, io, log, path, players, players_map, printStats, randomColor, removeGame, ringLoop, session, sharedsession, squareLoop, tick, uuid;

  PORT = 3330;

  log = console.log.bind(console);

  require('colors');

  express = require('express');

  uuid = function() {
    var i, k, possible, text;
    text = "";
    possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (i = k = 0; k < 8; i = ++k) {
      text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
  };

  bodyParser = require('body-parser');

  _ = require('lodash');

  path = require('path');

  fs = require('fs');

  sharedsession = require("express-socket.io-session");

  randomColor = require('random-color');

  Color = require('color');

  app = express();

  session = require("express-session")({
    secret: "fuck-cats",
    resave: true,
    saveUninitialized: true
  });

  Cooldown = class Cooldown {
    constructor(max_time1) {
      this.max_time = max_time1;
      this.t = null;
      this.beta = 1;
      this.time_left = null;
    }

    reset(time, max_time) {
      if (max_time) {
        this.max_time = max_time;
      }
      this.t = time + this.max_time;
      this.beta = 1;
      return this.time_left = this.max_time;
    }

    ok() {
      return this.beta === 0;
    }

    setMax(max_time1) {
      this.max_time = max_time1;
    }

    tick(time) {
      var ref;
      if ((this.beta === (ref = this.time_left) && ref <= 0)) {
        return;
      }
      if (!this.t) {
        return this.reset(time);
      }
      if (time >= this.t) {
        this.beta = 0;
        return this.time_left = 0;
      } else {
        this.time_left = this.t - time;
        return this.beta = this.time_left / this.max_time;
      }
    }

  };

  _time = Date.now();

  tick = function() {
    var game, k, len, results;
    _time = Date.now();
    results = [];
    for (k = 0, len = games.length; k < len; k++) {
      game = games[k];
      results.push(game.tick());
    }
    return results;
  };

  GRID_DIR = [[0, -1], [-1, 0], [0, 1], [1, 0]];

  ringLoop = function(x, y, radius, cb) {
    var i, j, k, m, ref, rx, ry;
    rx = x + radius;
    ry = y + radius;
    for (i = k = 0; k < 4; i = ++k) {
      for (j = m = 0, ref = radius * 2; 0 <= ref ? m < ref : m > ref; j = 0 <= ref ? ++m : --m) {
        if (!cb(rx, ry)) {
          return false;
        }
        rx += GRID_DIR[i][0];
        ry += GRID_DIR[i][1];
      }
    }
    return true;
  };

  squareLoop = function(x, y, radius, cb) {
    var i, k, ref;
    if (!cb(x, y)) {
      return false;
    }
    for (i = k = 1, ref = radius; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
      if (!ringLoop(x, y, i, cb)) {
        return false;
      }
    }
  };

  intersects = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
    if (ax2 < bx1 || ax1 > bx2 || ay2 < by1 || ay1 > by2) {
      return false;
    } else {
      return true;
    }
  };

  Game = class Game {
    constructor(opt) {
      this.calculateUnitNeighbors = this.calculateUnitNeighbors.bind(this);
      this.tick = this.tick.bind(this);
      this.compareEmpty = this.compareEmpty.bind(this);
      this.id = opt.id || uuid();
      this.sizeX = opt.sizeX;
      this.sizeY = opt.sizeY;
      this.resource_factor = opt.resource_factor || 1;
      this.unit_factor = opt.unit_factor || 1;
      this.grid = this.makeGrid(this.sizeX, this.sizeY);
      this.units_buffer = [];
      this.start_time = 0;
      this.total_turns = 1;
      this.type = opt.type;
      this.units = [];
      this.units_map = {};
      this.stamp = 0;
      this.players = [];
      this.dead_players = [];
      this.alive_players = [];
      this.turn_player = null;
      this.map_type = opt.map_type || 1;
      switch (this.map_type) {
        case 1:
          this.mapType1();
          break;
        case 2:
          this.mapType2();
          break;
        case 3:
          this.mapType3();
      }
      this.started = false;
      this.ended = false;
      log(`created a new game size:[${this.sizeX},${this.sizeY}] id:${this.id} type:${this.map_type}`.cyan);
    }

    setUnitType(unit_id, type, player) {
      var unit;
      type = _.clamp(Number(type), 0, 2);
      unit = this.units_map[unit_id];
      if (!unit) {
        throw new Error('bad unit');
      }
      if (unit.player !== player) {
        throw new Error('bad player');
      }
      // if !unit.actions
      // 	throw new Error 'cant move'

      // dice_needed = 1
      // if type == 3
      // 	dice_needed = 4

      // if unit.dice < dice_needed
      // 	throw new Error 'not enough dice'

      // unit.dice -= dice_needed
      unit.type = type;
      if (unit.linked_unit) {
        unit.linked_unit.linked_unit = null;
        unit.linked_unit = null;
      }
      unit.actions = 0;
      return this.needs_update = true;
    }

    removeUnit(unit) {
      var k, ref, ref1, results, x, y;
      this.units.splice(this.units.indexOf(unit), 1);
      delete this.units_map[unit.id];
      this.needs_update = true;
      results = [];
      for (x = k = ref = unit.x, ref1 = unit.x + unit.w; ref <= ref1 ? k < ref1 : k > ref1; x = ref <= ref1 ? ++k : --k) {
        results.push((function() {
          var m, ref2, ref3, results1;
          results1 = [];
          for (y = m = ref2 = unit.y, ref3 = unit.y + unit.h; ref2 <= ref3 ? m < ref3 : m > ref3; y = ref2 <= ref3 ? ++m : --m) {
            results1.push(this.grid[x][y] = -1);
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    addUnit(unit) {
      var k, ref, ref1, results, x, y;
      this.units_map[unit.id] = unit;
      this.units.push(unit);
      unit.grid = this;
      this.needs_update = true;
      results = [];
      for (x = k = ref = unit.x, ref1 = unit.x + unit.w; ref <= ref1 ? k < ref1 : k > ref1; x = ref <= ref1 ? ++k : --k) {
        results.push((function() {
          var m, ref2, ref3, results1;
          results1 = [];
          for (y = m = ref2 = unit.y, ref3 = unit.y + unit.h; ref2 <= ref3 ? m < ref3 : m > ref3; y = ref2 <= ref3 ? ++m : --m) {
            if (this.grid[x][y] !== -1) {
              log(x, y, this.grid[x][y].id);
              throw new Error('update grid failed!!');
            }
            results1.push(this.grid[x][y] = unit);
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    // # link energy units created adjacent to each other, but only once
    // if unit.type == 0 && !unit.linked_unit
    // 	@getNeighbors unit,(n)->
    // 		if n.type == 0 && n.player == unit.player && !n.linked_unit
    // 			return unit.linkUnit(n)
    updateGrid() {
      var dir, k, len, len1, m, n, o, p, ref, ref1, ref2, ref3, ref4, ref5, results, unit, x, y;
      this.grid = this.makeGrid(this.sizeX, this.sizeY);
      ref = this.units;
      for (k = 0, len = ref.length; k < len; k++) {
        unit = ref[k];
        unit.link_adjacent = false;
        for (x = m = ref1 = unit.x, ref2 = unit.x + unit.w; ref1 <= ref2 ? m < ref2 : m > ref2; x = ref1 <= ref2 ? ++m : --m) {
          for (y = o = ref3 = unit.y, ref4 = unit.y + unit.h; ref3 <= ref4 ? o < ref4 : o > ref4; y = ref3 <= ref4 ? ++o : --o) {
            if (this.grid[x][y] !== -1) {
              log(x, y, this.grid[x][y].id);
              throw new Error('update grid failed!!');
            }
            this.grid[x][y] = unit;
          }
        }
      }
      ref5 = this.units;
      results = [];
      for (p = 0, len1 = ref5.length; p < len1; p++) {
        unit = ref5[p];
        if (unit.link_adjacent) {
          continue;
        }
        results.push((function() {
          var len2, q, ref6, results1;
          results1 = [];
          for (q = 0, len2 = GRID_DIR.length; q < len2; q++) {
            dir = GRID_DIR[q];
            n = (ref6 = this.grid[unit.x + dir[0]]) != null ? ref6[unit.y + dir[1]] : void 0;
            if (n && n !== -1) {
              if (n.linked_unit === unit) {
                unit.link_adjacent = true;
                n.link_adjacent = true;
                break;
              } else {
                results1.push(void 0);
              }
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    attackPlayerUnit(u_id, n_id) {
      var n, u;
      u = this.units_map[u_id];
      n = this.units_map[n_id];
      if (!u || !n) {
        throw new Error('cant attack, bad unit');
      }
      if (!u.player || !n.player || u.player === n.player) {
        throw new Error('cant attack, bad player');
      }
      if (!n.neighbors_map[u_id] || !u.neighbors_map[n_id]) {
        throw new Error('cant attack, not neighbors');
      }
      return u.attack(n);
    }

    movePlayerUnit(state, player) {
      var id, k, m, o, p, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, unit, ux, uy, x, y, z;
      id = state.id;
      x = Number(state.x);
      y = Number(state.y);
      unit = this.units_map[id];
      if (unit.player !== player) {
        throw new Errpr('cant move unit, bad player');
      }
      if (!unit.actions) {
        throw new Error('cant move unit, no action points');
      }
      if (x < unit.x) {
        x = unit.x - 1;
        y = unit.y;
      }
      if (x >= unit.x + unit.w) {
        x = unit.x + 1;
        y = unit.y;
      }
      if (y < unit.y) {
        x = unit.x;
        y = unit.y - 1;
      }
      if (y >= unit.y + unit.h) {
        x = unit.x;
        y = unit.y + 1;
      }
      for (ux = k = 0, ref = unit.w; 0 <= ref ? k < ref : k > ref; ux = 0 <= ref ? ++k : --k) {
        for (uy = m = 0, ref1 = unit.h; 0 <= ref1 ? m < ref1 : m > ref1; uy = 0 <= ref1 ? ++m : --m) {
          if (((ref2 = this.grid[x + ux]) != null ? ref2[y + uy] : void 0) !== -1 && this.grid[x + ux][y + uy] !== unit) {
            if (this.grid[x + ux][y + uy] && this.grid[x + ux][y + uy].player === unit.player) {
              this.needs_update = true;
              return unit.moveDice(this.grid[x + ux][y + uy]);
            } else {
              throw new Error('cant move unit, taken');
            }
          }
        }
      }
      for (ux = o = 0, ref3 = unit.w; 0 <= ref3 ? o < ref3 : o > ref3; ux = 0 <= ref3 ? ++o : --o) {
        for (uy = p = 0, ref4 = unit.h; 0 <= ref4 ? p < ref4 : p > ref4; uy = 0 <= ref4 ? ++p : --p) {
          this.grid[unit.x + ux][unit.y + uy] = -1;
        }
      }
      for (ux = q = 0, ref5 = unit.w; 0 <= ref5 ? q < ref5 : q > ref5; ux = 0 <= ref5 ? ++q : --q) {
        for (uy = z = 0, ref6 = unit.h; 0 <= ref6 ? z < ref6 : z > ref6; uy = 0 <= ref6 ? ++z : --z) {
          this.grid[x + ux][y + uy] = unit;
        }
      }
      unit.setPos(x, y);
      unit.actions = 0;
      return this.needs_update = true;
    }

    placePlayerUnit(place_unit, player) {
      var h_count, h_dice, h_units, k, len, len1, m, need_dice, ref, ref1, u, unit;
      place_unit.type = _.clamp(Number(place_unit.type), 0, 3);
      place_unit.x = Number(place_unit.x);
      place_unit.y = Number(place_unit.y);
      if (place_unit.x < 0 || place_unit.x > this.sizeX) {
        throw new Error('cant place unit, bounds');
      }
      if (place_unit.y < 0 || place_unit.y > this.sizeY) {
        throw new Error('cant place unit, bounds');
      }
      h_count = 0;
      h_dice = 0;
      h_units = [];
      ref = player.units;
      for (k = 0, len = ref.length; k < len; k++) {
        u = ref[k];
        if (u.type === 3 && Math.abs(u.x - place_unit.x) < 2 && Math.abs(u.y - place_unit.y) < 2) {
          h_count++;
          h_dice += u.dice;
          h_units.push(u);
        }
      }
      need_dice = 0;
      if (place_unit.type === 3) {
        need_dice = 4;
      } else {
        need_dice = 1;
      }
      if (!h_count) {
        throw new Error('cant place unit, home unit bounds');
      }
      if (h_dice < need_dice) {
        throw new Error('cant place unit, home unit not enough dice');
      }
      if (((ref1 = this.grid[place_unit.x]) != null ? ref1[place_unit.y] : void 0) !== -1) {
        throw new Error('cant place unit, taken');
      }
      for (m = 0, len1 = h_units.length; m < len1; m++) {
        u = h_units[m];
        if (u.dice >= need_dice) {
          u.dice -= need_dice;
          need_dice = 0;
        } else {
          u.dice = 0;
          need_dice -= u.dice;
        }
      }
      unit = new Unit({
        dice: h_count - 1,
        type: place_unit.type,
        x: place_unit.x,
        y: place_unit.y,
        player: player
      });
      return player.addUnit(unit);
    }

    getNeighbors(unit, cb) {
      var k, m, ref, ref1, results, x, y;
      for (y = k = 0, ref = unit.h; 0 <= ref ? k < ref : k > ref; y = 0 <= ref ? ++k : --k) {
        // left neigh
        if (this.grid[unit.x - 1] && (this.grid[unit.x - 1][unit.y + y] != null) && this.grid[unit.x - 1][unit.y + y] !== -1) {
          cb(this.grid[unit.x - 1][unit.y + y]);
        }
        // right neih
        if (this.grid[unit.x + unit.w] && this.grid[unit.x + unit.w][unit.y + y] && this.grid[unit.x + unit.w][unit.y + y] !== -1) {
          cb(this.grid[unit.x + unit.w][unit.y + y]);
        }
      }
      results = [];
      for (x = m = 0, ref1 = unit.w; 0 <= ref1 ? m < ref1 : m > ref1; x = 0 <= ref1 ? ++m : --m) {
        // top neigh
        if (this.grid[unit.x + x] && (this.grid[unit.x + x][unit.y - 1] != null) && this.grid[unit.x + x][unit.y - 1] !== -1) {
          cb(this.grid[unit.x + x][unit.y - 1]);
        }
        // bot neih
        if (this.grid[unit.x + x] && (this.grid[unit.x + x][unit.y + unit.h] != null) && this.grid[unit.x + x][unit.y + unit.h] !== -1) {
          results.push(cb(this.grid[unit.x + x][unit.y + unit.h]));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    calculateUnitNeighbors() {
      var k, len, ref, results, unit;
      ref = this.units;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        unit = ref[k];
        unit.resetNeighbors();
        results.push(this.getNeighbors(unit, function(n) {
          return unit.addNeighbor(n);
        }));
      }
      return results;
    }

    tick() {
      var k, len, player, ref;
      if (this.ended && this.needs_update) {
        this.needs_update = false;
        this.emitState();
        return;
      }
      ref = this.players;
      for (k = 0, len = ref.length; k < len; k++) {
        player = ref[k];
        player.tick();
      }
      if (this.needs_update) {
        this.needs_update = false;
        return this.emitUpdate();
      }
    }

    nextTurn() {
      this.total_turns++;
      this.turn_index++;
      if (this.turn_index >= this.alive_players.length) {
        this.turn_index = 0;
      }
      this.needs_update = true;
      return this.alive_players[this.turn_index].startTurn();
    }

    emitUpdate() {
      this.calculateUnitNeighbors();
      this.updateGrid();
      this.serializeUnits();
      return this.emitState();
    }

    getState() {
      return {
        players: this.players.map(function(player) {
          return player.getState();
        }),
        turn_player_i: this.players.indexOf(this.turn_player),
        max_players: this.max_players,
        map_type: this.map_type,
        sizeY: this.sizeY,
        sizeX: this.sizeX,
        id: this.id,
        stamp: this.stamp,
        ended: this.ended,
        started: this.started,
        total_turns: this.total_turns,
        turn_end_time: this.turn_end_time,
        start_time: this.start_time,
        units: this.units_buffer,
        stats: this.getStats()
      };
    }

    getStats() {
      if (!this.ended) {
        return null;
      }
      return {
        total_time: this.end_time - this.start_time,
        total_turns: this.total_turns / this.players.length,
        alive_players: this.alive_players.map(function(player) {
          return player.getState();
        }),
        dead_players: this.dead_players.map(function(player) {
          return player.getState();
        })
      };
    }

    emitStats() {
      var k, len, player, ref, results;
      ref = this.player;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        player = ref[k];
        results.push(player.instance.emit('game_stats'));
      }
      return results;
    }

    killPlayer(player) {
      var k, len, len1, m, ref, ref1, t, unit;
      // @players.splice(@players.indexOf(player),1)
      player.dead = true;
      this.alive_players.splice(this.alive_players.indexOf(player), 1);
      this.dead_players.push(player);
      ref = player.units;
      for (k = 0, len = ref.length; k < len; k++) {
        unit = ref[k];
        this.removeUnit(unit);
      }
      // player.game = null
      if (this.alive_players.length === 1 && !this.ended) {
        this.end();
      } else {
        t = null;
        ref1 = this.players;
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          player = ref1[m];
          if (t === null) {
            t = player.team_id;
          }
          if (player.team !== t) {
            t = null;
            break;
          }
        }
        if (t !== null) {
          this.end();
        }
      }
      return this.needs_update = true;
    }

    removePlayer(player) {
      this.players.splice(this.players.indexOf(player), 1);
      player.game = null;
      player.reset();
      player.emitState();
      if (this.players.length === 0) {
        removeGame(this);
      }
      return this.needs_update = true;
    }

    addPlayer(player) {
      if (this.started) {
        throw new Error('game already started');
      }
      if (this.players.length === this.max_players) {
        throw new Error('game has reached max players');
      }
      if (this.players.indexOf(player) >= 0) {
        throw new Error('you are already in this game');
      }
      if (player.game) {
        throw new Error('you are already in a game');
      }
      this.players.push(player);
      player.game = this;
      // @start()
      return this.emitState();
    }

    serializeUnits() {
      var i, k, len, ref, results, u;
      this.stamp = _time;
      this.units_buffer = [];
      ref = this.units;
      results = [];
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        u = ref[i];
        results.push(this.units_buffer[i] = u.getState());
      }
      return results;
    }

    findFreeHomeUnitSpot(x, y) {
      var pcx, pcy, radius, spot, taken;
      // log 'FINDFREE HOME UNTI SPOT',x,y
      radius = this.sizeY > this.sizeX && Math.floor(this.sizeY / 2) || Math.floor(this.sizeX / 2);
      taken = 0;
      pcx = null;
      pcy = null;
      spot = this.findFreeSpot(x, y, 3, 3, radius, (fx, fy, cx, cy) => {
        var ref;
        if (((ref = this.grid[cx + 1]) != null ? ref[cy + 1] : void 0) !== -1) {
          return false;
        }
        // log 'compare',fx,fy
        if (cx !== pcx || cy !== pcy) {
          taken = 0;
        }
        pcx = cx;
        pcy = cy;
        // do not intersect with other home units.
        if (this.grid[fx] && (this.grid[fx][fy] != null) && this.grid[fx][fy].type === 3) {
          // log 'false (type == 3)'
          return false;
        }
        // free spot, we are good
        if ((this.grid[fx] != null) && this.grid[fx][fy] === -1) {
          // log 'true (free)'
          return true;
        }
        taken++;
        if (taken === 4) {
          taken = 0;
          // log 'false (taken max)'
          return false;
        }
        // log 'true (base)'
        return true;
      });
      log('found home unit spot', spot);
      if (spot[0] !== null && spot[0] !== null) {
        spot[0] += 1;
        spot[1] += 1;
      }
      return spot;
    }

    findFreeSpot(x, y, w, h, radius, compare) {
      var found_x, found_y;
      found_x = null;
      found_y = null;
      squareLoop(x, y, radius, function(fx, fy) {
        var c, k, m, ok, r, ref, ref1;
        ok = true;
        for (c = k = 0, ref = w; 0 <= ref ? k < ref : k > ref; c = 0 <= ref ? ++k : --k) {
          for (r = m = 0, ref1 = h; 0 <= ref1 ? m < ref1 : m > ref1; r = 0 <= ref1 ? ++m : --m) {
            if (!compare(fx + c, fy + r, fx, fy)) {
              ok = false;
              found_x = null;
              found_y = null;
              return true;
            }
          }
        }
        if (ok) {
          found_x = fx;
          found_y = fy;
          return false;
        }
      });
      log('found free spot', found_x, found_y);
      return [found_x, found_y];
    }

    emitUnits() {
      var k, len, ref, results, unit;
      ref = this.units;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        unit = ref[k];
        results.push(this.emit('units', unit.getJson()));
      }
      return results;
    }

    setTurn(player) {
      return player.startTurn();
    }

    pickRandomPlayer() {
      return this.alive_players[Math.floor(Math.random() * this.alive_players.length)];
    }

    start() {
      var first_turn_player;
      log('start game', this.id);
      this.start_time = _time;
      this.alive_players = this.players.slice();
      if (this.map_type === 1) {
        this.SpawnMapType1();
      }
      first_turn_player = this.pickRandomPlayer();
      first_turn_player.startTurn();
      this.started = true;
      return this.needs_update = true;
    }

    end() {
      var k, len, player, ref;
      log('END GAME');
      this.ended = true;
      this.end_time = _time;
      ref = this.players;
      for (k = 0, len = ref.length; k < len; k++) {
        player = ref[k];
        player.reset();
      }
      this.needs_update = true;
      this.units = [];
      return this.grid = [];
    }

    makeGrid(w, h) {
      var grid, k, m, ref, ref1, x, y;
      grid = [];
      for (x = k = 0, ref = w; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
        grid[x] = [];
        for (y = m = 0, ref1 = h; 0 <= ref1 ? m < ref1 : m > ref1; y = 0 <= ref1 ? ++m : --m) {
          grid[x][y] = -1;
        }
      }
      return grid;
    }

    emitState() {
      var k, len, player, ref, results;
      ref = this.players;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        player = ref[k];
        results.push(player.emitState());
      }
      return results;
    }

    compareEmpty(fx, fy, cx, cy) {
      // free spot, we are good
      if ((this.grid[fx] != null) && this.grid[fx][fy] === -1) {
        return true;
      }
      return false;
    }

    mapType1() {
      var i, k, l, mx, my, r_h, r_w, r_x, r_y, ref, resource, results, spot;
      my = Math.floor(this.sizeY / 2);
      mx = Math.floor(this.sizeX / 2);
      l = (this.sizeX * this.sizeY) / 12 * this.resource_factor;
      results = [];
      for (i = k = 0, ref = l; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        r_x = Math.floor(Math.random() * this.sizeX);
        r_y = Math.floor(Math.random() * this.sizeY);
        r_w = Math.floor(1 + Math.random() * 1.5);
        r_h = Math.floor(1 + Math.random() * 1.5);
        spot = this.findFreeSpot(r_x, r_y, r_w, r_h, 2, this.compareEmpty);
        if ((spot[0] != null) && (spot[1] != null)) {
          resource = new ResourceUnit({
            x: spot[0],
            y: spot[1],
            w: r_w,
            h: r_h
          });
          results.push(this.addUnit(resource));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    SpawnMapType1() {
      var h_unit, h_x, h_y, i, k, len, player, pos, ref, results, total_units;
      total_units = this.sizeX * this.sizeY / 2 * this.unit_factor;
      ref = this.alive_players;
      results = [];
      for (i = k = 0, len = ref.length; k < len; i = ++k) {
        player = ref[i];
        results.push((function() {
          var m, ref1, results1;
          results1 = [];
          for (m = 0, ref1 = total_units / this.alive_players.length; 0 <= ref1 ? m < ref1 : m > ref1; 0 <= ref1 ? m++ : m--) {
            h_unit = new Unit({
              type: Math.floor(0 + Math.random() * 3),
              dice: Math.floor(0 + Math.random() * 8),
              actions: 1,
              w: 1,
              h: 1,
              player: player
            });
            h_x = Math.floor(Math.random() * this.sizeX);
            h_y = Math.floor(Math.random() * this.sizeY);
            pos = this.findFreeSpot(h_x, h_y, 1, 1, 4, this.compareEmpty);
            if ((pos[0] != null) && (pos[1] != null)) {
              h_unit.setPos(pos[0], pos[1]);
              results1.push(player.addUnit(h_unit));
            } else {
              results1.push(console.log(pos, 'failed to spawn unit'));
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    }

  };

  Unit = class Unit {
    constructor(opt) {
      this.getState = this.getState.bind(this);
      this.id = uuid();
      this.w = 1;
      this.h = 1;
      this.x = opt.x;
      this.y = opt.y;
      this.next_x = this.x;
      this.next_y = this.y;
      this.type = opt.type; //  0:resource,  1:attack,  2:def,  3:home, 4: resource
      this.link_adjacent = false;
      this.dice = opt.dice || 0;
      this.actions = opt.actions || 0;
      this.max_actions = 4;
      this.max_dice = 8;
      this.linked_unit = opt.linked_unit;
      this.player = opt.player || null;
      this.neighbors_map = {};
      this.neighbors = [];
    }

    resetNeighbors() {
      // @neighbor_ids = []
      this.neighbors = [];
      return this.neighbors_map = {};
    }

    addNeighbor(unit) {
      if (!this.neighbors_map[unit.id]) {
        // @neighbor_ids.push unit.id
        this.neighbors.push(unit);
        return this.neighbors_map[unit.id] = unit;
      }
    }

    moveDice(unit) {
      var rem;
      if (!this.dice) {
        throw new Error('cant move dice, no dice.');
      }
      rem = (unit.dice + this.dice) - unit.max_dice;
      if (rem > 0) {
        this.dice = rem;
        unit.dice = unit.max_dice;
      } else {
        unit.dice += this.dice;
        this.dice = 0;
      }
      return this.actions--;
    }

    unlink() {
      if (this.linked_unit) {
        this.linked_unit.linked_unit = null;
      }
      return this.linked_unit = null;
    }

    link(unit) {
      if (unit === this.linked_unit) {
        throw new Error('cant link, same unit is already linked.');
      }
      if (this.linked_unit) {
        this.linked_unit.unlink();
      }
      unit.unlink();
      if (this.actions === 0 || unit.actions === 0) {
        throw new Error('cant link, not enough action points.');
      }
      if (unit.type !== this.type) {
        throw new Error('cant link, types not the same.');
      }
      this.actions -= 1;
      this.linked_unit = unit;
      this.linked_unit.actions -= 1;
      return this.linked_unit.linked_unit = this;
    }

    refillDice() {
      return this.dice += 1;
    }

    equalizeDice(unit) {
      var results;
      results = [];
      while (this.dice && this.dice > unit.dice && unit.dice < unit.max_dice) {
        unit.dice += 1;
        results.push(this.dice -= 1);
      }
      return results;
    }

    addOneDice(ret) {
      if (this.dice === this.max_dice) {
        if (!ret && this.linked_unit && this.link_adjacent) {
          return this.linked_unit.addOneDice(true);
        } else {
          return false;
        }
      } else {
        this.dice++;
        return true;
      }
    }

    removeOneDice(ret) {
      if (this.dice > 0) {
        this.dice -= 1;
        return true;
      } else if (!ret && this.linked_unit && this.link_adjacent) {
        return this.linked_unit.removeOneDice(true);
      } else {
        return false;
      }
    }

    giveDice(unit) {
      while (this.removeOneDice()) {
        if (!unit.addOneDice()) {
          this.addOneDice();
          return;
        }
      }
    }

    getState() {
      return {
        x: this.x,
        y: this.y,
        w: this.w,
        h: this.h,
        next_x: this.next_x,
        next_y: this.next_y,
        type: this.type,
        dice: this.dice,
        id: this.id,
        linked_unit_id: this.linked_unit && this.linked_unit.id,
        link_adjacent: this.link_adjacent,
        actions: this.actions,
        player_id: this.player && this.player.id
      };
    }

    setPos(x1, y1) {
      this.x = x1;
      this.y = y1;
      this.next_x = this.x;
      return this.next_y = this.y;
    }

    movePos(x, y) {
      this.next_x = x;
      return this.next_y = y;
    }

    
    // each dice has 6 sides, roll the dice based on how many dice unit has.
    _roll() {
      var i, k, ref, total;
      total = 0;
      for (i = k = 0, ref = this.dice; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        total += 1 + Math.floor(Math.random() * 6);
      }
      return total;
    }

    // public roll method, roll depends on unit type.
    roll(attacker) {
      var v;
      if (!attacker && this.type === 2) {
        v = this._roll() * 3;
      } else if (attacker && this.type === 1) {
        v = this._roll() * 2;
      } else {
        v = this._roll();
      }
      if (this.linked_unit && this.link_adjacent) {
        v += this.linked_unit._roll();
      }
      return v;
    }

    attack(unit) {
      var vA, vB;
      if (!this.actions) {
        throw new Error('cant attack, !can_move');
      }
      if (this.type === 2) {
        throw new Error('defensive units cant attack other units.');
      }
      if (this.dice === 0) {
        throw new Error('empties cant attack');
      }
      vA = unit.roll(false);
      vB = this.roll(true);
      if (this.linked_unit && this.link_adjacent) {
        vB += this.linked_unit._roll();
      }
      log('roll attacker:', vB, ' - defender:', vA);
      if (vB > vA) {
        if (unit.linked_unit) {
          unit.linked_unit.dice = 0;
        }
        unit.dice = this.dice - 1;
        this.dice = 0;
        unit.player.units.splice(unit.player.units.indexOf(unit), 1);
        unit.player = this.player;
        unit.unlink();
        this.player.units.push(unit);
      } else {
        this.dice = 0;
      }
      return this.grid.needs_update = true;
    }

  };

  ResourceUnit = class ResourceUnit extends Unit {
    constructor(opt) {
      super(opt);
      this.type = 4;
    }

  };

  DECK = [[1, 1], [1, 1], [1, 2], [2, 1]];

  Player = class Player {
    constructor(opt) {
      this.joinGame = this.joinGame.bind(this);
      this.createGame = this.createGame.bind(this);
      this.gameStart = this.gameStart.bind(this);
      // set game settings
      this.gameSet = this.gameSet.bind(this);
      
      // x = place_unit(place_unit.x)

      // 	if state.place_unit.x

      // 	if state.place_unit.y

      // 		state.place_unit.card && state.place_unit.type

      // log 'GAME PUT'
      this.gamePut = this.gamePut.bind(this);
      this.catchEvent = this.catchEvent.bind(this);
      this.name = opt.name || 'Player ' + (players.length + 1);
      this.instance = opt.instance;
      this.id = this.instance.id;
      this.cards = [];
      this.max_cards = 3;
      this.units = [];
      this.team_id = 0;
      this.turn_time = 120000;
      this.color = randomColor(0.7, 0.99).values.rgb;
      players.push(this);
      players_map[this.id] = this;
      this.bindSocket(opt.socket);
      this.turn_cooldown = new Cooldown(this.turn_time);
    }

    tickTurnDice() {
      var k, len, ref, results, unit;
      ref = this.units;
      // generate
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        unit = ref[k];
        if (unit.actions < unit.max_actions) {
          unit.actions += 1;
        }
        if (unit.type === 0) {
          results.push(unit.addOneDice());
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    
    // 	for n in unit.neighbors
    // 		if n.type == 4 
    // 			unit.addOneDice()

    // # resupply
    // for unit in @units
    // 	if unit.type == 0
    // 		for n in unit.neighbors
    // 			if (n.type == 1 || n.type == 2 || n.type == 3) && n.player == unit.player
    // 				unit.giveDice(n)

    // @equalizeUnits()

    // equalizeUnits: ()->
    // 	# equalize
    // 	for unit in @units
    // 		if unit.type == 0

    // 			if unit.linked_unit
    // 				if unit.dice > unit.linked_unit.dice

    // 					unit.equalizeDice(unit.linked_unit)

    // 			for n in unit.neighbors
    // 				if unit.type == n.type && n.player == unit.player
    // 					if unit.dice > n.dice

    // 						unit.equalizeDice(n)
    reset() {
      return this.units = [];
    }

    die() {
      return this.game.killPlayer(this);
    }

    removeUnit(unit) {
      this.units.splice(this.units.indexOf(unit), 1);
      unit.player = null;
      this.game.removeUnit(unit);
      if (unit.type === 3) {
        return this.die();
      }
    }

    addUnit(unit) {
      this.units.push(unit);
      unit.player = this;
      return this.game.addUnit(unit);
    }

    tick() {
      this.turn_cooldown.tick(_time);
      if (this.turn_cooldown.beta === 0 && this.turn_active) {
        return this.endTurn();
      }
    }

    startTurn() {
      this.game.turn_player = this;
      this.game.turn_index = this.game.players.indexOf(this);
      this.turn_active = true;
      this.turn_end_time = _time + this.turn_time;
      this.game.turn_end_time = this.turn_end_time;
      return this.turn_cooldown.reset(_time);
    }

    endTurn() {
      if (this.ended) {
        return;
      }
      this.turn_active = false;
      this.tickTurnDice();
      return this.game.nextTurn();
    }

    joinGame(id) {
      var e;
      if (!games_map[id]) {
        return this.instance.emitErr('game does not exist');
      } else {
        try {
          return games_map[id].addPlayer(this);
        } catch (error) {
          e = error;
          this.instance.emitErr(e.message);
          return this.instance.emitState();
        }
      }
    }

    createGame(state) {
      var game;
      game = createGame(new Game({
        sizeX: _.clamp(Number(state.sizeX), 8, 100),
        sizeY: _.clamp(Number(state.sizeY), 8, 100),
        type: _.clamp(Number(state.type), 1, 3),
        unit_factor: _.clamp(Number(state.unit_factor), 0, 10),
        resource_factor: _.clamp(Number(state.resource_factor), 0, 10)
      }));
      return game.addPlayer(this);
    }

    gameStart() {
      if (this.game.started) {
        return this.instance.emitErr('game is already started? :<');
      }
      return this.game.start();
    }

    gameSet(state) {
      var player, team_id;
      if (state.player_team && (state.player_team[0] != null) && (state.player_team[1] != null)) {
        if (!this.game) {
          return this.instance.emitErr('you are not in a game? :<');
        }
        if (this.game.players[0] !== this) {
          return this.instance.emitErr('you are not the game creator? :<');
        }
        player = players_map[state.player_team[0]];
        if (!player) {
          return this.instance.emitErr('player not found. :<');
        } else if (player.game !== this.game) {
          return this.instance.emitErr('player not in your game. :<');
        }
        team_id = _.clamp(Number(state.player_team[1]), 0, 4);
        player.team_id = team_id;
        return this.game.emitState();
      }
    }

    gamePut(state) {
      if (!this.turn_active) {
        throw new Error('not your turn :<');
      }
      if (state.unit_type) {
        this.game.setUnitType(state.unit_type.id, state.unit_type.type, this);
      } else if (state.attack_unit) {
        this.game.attackPlayerUnit(state.attack_unit.u_id, state.attack_unit.n_id);
      } else if (state.move_unit) {
        this.game.movePlayerUnit(state.move_unit, this);
      } else if (state.place_unit) {
        this.game.placePlayerUnit(state.place_unit, this);
      }
      if (state.end_turn) {
        return this.endTurn();
      }
    }

    catchEvent(fn) {
      return (state) => {
        var e;
        try {
          return fn(state);
        } catch (error) {
          e = error;
          return this.instance.emitErr(e.message);
        }
      };
    }

    bindSocket(s) {
      this.socket = s;
      s.on('create', this.catchEvent(this.createGame));
      s.on('join', this.catchEvent(this.joinGame));
      s.on('game_set', this.catchEvent(this.gameSet));
      s.on('game_start', this.catchEvent(this.gameStart));
      s.on('game_put', this.catchEvent(this.gamePut));
      return s.on('leave', () => {
        if (this.game) {
          return this.game.removePlayer(this);
        }
      });
    }

    emitState() {
      return this.instance.emitState();
    }

    getState() {
      return {
        id: this.id,
        name: this.name,
        cards: this.cards,
        team_id: this.team_id,
        color: this.color,
        turn_end_time: this.turn_end_time
      };
    }

  };

  Instance = class Instance {
    constructor(socket) {
      log('new instance');
      this.id = uuid();
      this.socket = socket;
      this.session = this.socket.handshake.session;
      this.session.instance_id = this.id;
      this.session.save();
      this.player = new Player({
        instance: this,
        socket: this.socket,
        name: null
      });
    }

    getState() {
      return {
        player: this.player.getState(),
        game: this.player.game && this.player.game.getState()
      };
    }

    emitState() {
      return this.socket.emit('state', this.getState());
    }

    emitErr(msg) {
      return this.socket.emit('err', msg);
    }

    reconnect(socket1) {
      this.socket = socket1;
      log('reconnect instance');
      return this.player.bindSocket(this.socket);
    }

  };

  instances_map = [];

  instances = [];

  players = [];

  players_map = {};

  games_map = {};

  games = [];

  removeGame = function(game) {
    delete games_map[game.id];
    return games.splice(games.indexOf(game), 1);
  };

  createGame = function(game) {
    games_map[game.id] = game;
    games.push(game);
    return game;
  };

  // createGame new Game
  // 	sizeX: 8
  // 	sizeY: 8
  // 	id: 'dev'
  printStats = function() {
    return log(games.length + " games | " + players.length + " players | " + instances.length + " instances");
  };

  setInterval(printStats, 60000);

  app.set('view engine', 'pug').set('views', './client-views').use('/static', express.static('./client-static')).use(bodyParser.json()).use(bodyParser.urlencoded({
    extended: false
  })).use(session);

  http = require('http').Server(app);

  io = require('socket.io')(http);

  io.use(sharedsession(session, {
    autoSave: true
  }));

  app.get('/', function(req, res) {
    return res.render('index');
  });

  // global 404 view
  app.get('*', function(req, res, next) {
    return res.status(404).send(':v');
  // global error view
  }).use(function(err, req, res, next) {
    if (err.message.match('duplicate key error index')) {
      return res.json({
        error: 'oops, duplicate found'
      });
    }
    res.json({
      error: err.message
    });
    throw err;
  });

  io.on('connection', function(socket) {
    var inst, inst_id;
    log(socket);
    inst_id = socket.handshake.session.instance_id;
    inst = instances_map[inst_id];
    // if inst
    // 	inst.reconnect(socket)
    // else
    inst = new Instance(socket);
    instances_map[inst.id] = inst;
    return instances.push(inst);
  });

  http.listen(PORT, function() {
    log('-- blokd -- '.cyan);
    return log(('port: ' + PORT).bold);
  });

  setInterval(tick, 33);

}).call(this);
